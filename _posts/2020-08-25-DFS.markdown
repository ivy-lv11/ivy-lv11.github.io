---
layout: post
title:  Leetcode-DFS
date:   2020-08-25 15:01:35 +0300
image:  07.jpg
tags:   Home
---
## 记录leetcode上面DFS的题目
#### 1. 1519
思路：无向图上的DFS。用link作为邻接矩阵，用count记下子树中每个字母的出现次数
```
class Solution {
    vector<vector<int>> count;
    vector<vector<int>> link;
    int* map;
    string label;
public:
    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        count.resize(n);
        link.resize(n);
        label = labels;
        for(int i=0;i<n;i++)
        {
            count[i].resize(26);
        }
        for(int i=0;i<edges.size();i++)
        {
            link[edges[i][0]].push_back(edges[i][1]);
            link[edges[i][1]].push_back(edges[i][0]);
        }
        
        map = new int[n];
        memset(map,0,n*sizeof(int));
        dfs(0);
        vector<int> re;
        for(int i=0;i<n;i++)
        {
            re.push_back(count[i][label[i]-'a']);
        }
        return re;
    }
    bool dfs(int id)
    {
        if(map[id]==1)
            return false;
        map[id] = 1;
        count[id][label[id]-'a']++;
        if(link[id].empty()==true)
            return false;
        for(int i=0;i<link[id].size();i++)
        {
            bool x = dfs(link[id][i]);
            if(x!=false){
            for(int k=0;k<26;k++)
                count[id][k] += count[link[id][i]][k];
            }
        }
        return true;      
    }
};
```

#### 2. [检查搜索二叉树](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)
思路：递归，左右子树都是搜索二叉树，且左子树最大值小于根节点的值，且右子树最小值大于根结点的值，return true; 否则return false
```
struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };

class Solution {
public:
    int get_min(TreeNode* ptr)
    {
        TreeNode* tmp = ptr;
        while(tmp->left!=NULL)
            tmp = tmp->left;
        return tmp->val;
    }
    int get_max(TreeNode* ptr)
    {
          TreeNode* tmp = ptr;
        while(tmp->right!=NULL)
            tmp = tmp->right;
        return tmp->val;  
    }
    bool isValidBST(TreeNode* root) {
        if(root==NULL)
            return true;
        if(root->left==NULL && root->right==NULL)
            return true;
        else if(root->left==NULL && root->right!=NULL)
        {
            bool b1 = isValidBST(root->right);
            if(b1 && get_min(root->right) > root->val)
                return true;
            else
                return false;
        }
        else if(root->left!=NULL && root->right==NULL )
        {
            bool b1 = isValidBST(root->left);
            if(b1 && get_max(root->left) < root->val)
                return true;
            else
                return false;
        }
        else
        {
            bool b1 = isValidBST(root->left);
            bool b2 = isValidBST(root->right);
            if(b1 && b2 && root->val>get_max(root->left) && get_min(root->right) >root->val)
                return true;
            return false;
        }
        return false;
    }
};
```
#### 3. [字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)  
思路：回溯算法
```
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        map<char,string> dict;
        dict['2'] = string("abc");
        dict['3'] = string("def");
        dict['4'] = string("ghi");
        dict['5'] = string("jkl");
        dict['6'] = string("mno");
        dict['7'] = string("pqrs");
        dict['8'] = string("tuv");
        dict['9'] = string("wxyz");
        vector<string> re;
        for(int i=0;i<digits.size();i++)
        {
            if(re.empty())
            {
                char ch = digits[i];
                for(int j=0;j<dict[ch].size();j++)
                {
                    char add = dict[ch][j];
                    char t[10];
                    sprintf(t,"%c",add);
                    re.push_back(string(t));
                }
            }
            else
            {
                char ch = digits[i];
                vector<string> pre ;
                for(int j=0;j<dict[ch].size();j++)
                {
                    char add = dict[ch][j];
                    char t[10];
                    sprintf(t,"%c",add);
                    string temp(t);
                    for(int k=0;k<re.size();k++)
                    {
                        pre.push_back( re[k]+temp);
                    }
                }
                re = pre;
            }
        }
        return re;
    }   
};
```

#### 4. [池塘面积](https://leetcode-cn.com/problems/pond-sizes-lcci/)
思路：DFS，在图上进行DFS
```
class Solution {
    vector<vector<int>> dic;
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> re;
        for(int i=0;i<land.size();i++)
        {
            vector<int> temp;
            for(int j=0;j<land[0].size();j++)
                temp.push_back(0);
            dic.push_back(temp);
        }

        for(int i=0;i<land.size();i++)
        {
            for(int j=0;j<land[0].size();j++)
            {
               int count = dfs(i,j,land);
               if(count!=0)
                    re.push_back(count); 
            }
        }
        sort(re.begin(),re.end());
        return re;
    }
    int dfs(int i,int j,vector<vector<int>>& land)
    {
        if(dic[i][j]==1)
            return 0;
        dic[i][j] = 1;
        int x = 0;
        if(land[i][j]==0)
        {
            x ++;
            if(i+1<land.size())
                x += dfs(i+1,j,land);
            if(j+1<land[0].size())
                x += dfs(i,j+1,land);
            if(i-1>=0)
                x += dfs(i-1,j,land);
            if(j-1 >=0)
                x += dfs(i,j-1,land);
            if(i+1<land.size() && j+1<land[0].size())
                x += dfs(i+1,j+1,land);
            if(i+1<land.size() && j-1 >=0)
                x += dfs(i+1,j-1,land);
            if(i-1>=0 && j+1 <land[0].size())
                x += dfs(i-1,j+1,land);
            if(i-1>=0 && j-1>=0 )
                x += dfs(i-1,j-1,land);
        }
        return x;
    }
};
```

#### 5.[翻转二叉树匹配](https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/)
```

```

#### 6. [求根节点到叶节点的数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
思路：直接在树上DFS，注意转成string，可以方便的连接
```
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        vector<string> re = dfs(root);
        int sum= 0;
        for(vector<string>::iterator it = re.begin();it!=re.end();it++)
            sum += atoi(it->c_str());
        return sum;

    }
    vector<string> dfs(TreeNode* root)
    {
        vector<string> re;
        if(root==NULL)
            return re;
        if(root->left==NULL && root->right==NULL)
        {
            int x = root->val;
            char s[20];
            sprintf(s,"%d",x);

            re.push_back(string(s));
            return re;
        }
        vector<string> l = dfs(root->left);
        vector<string> r = dfs(root->right);
        int val = root->val;
        char str[5];
        sprintf(str,"%d",val);
        string str2(str);
        for(vector<string>::iterator it = l.begin();it!=l.end();it++)
        {
            string str3 = *it;
            string str4 = str2+str3;
            re.push_back(str4);

        }
        for(vector<string>::iterator it = r.begin();it!=r.end();it++)
        {
            string str3 = *it;
            string str4 = str2+str3;
            re.push_back(str4);

        }
        return re;
    }

};
```

#### 7.[朋友圈](https://leetcode-cn.com/problems/friend-circles/)
思路：求解连通分量的个数，直接DFS就好

#### 8. [婴儿名字](https://leetcode-cn.com/problems/baby-names-lcci/)
思路：可以采用DFS三步走
* 建立邻接矩阵，把问题转化成为熟悉的图问题
* 在图上面进行DFS，找到各个连通分量
* 对连通分量进行计数，输出  
当然更快的方法是使用并查集，这在后面会专门有一节blog

#### 9. [树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)
思路：这一题直接去BFS，按层遍历访问节点，自然得到最左边的

#### 10. [二分类](https://leetcode-cn.com/problems/possible-bipartition/)
思路：可不就是算法导论DFS一道课后习题嘛！dislike关系构成邻接矩阵，然后DFS，染色检查。注意：图不一定是联通的，可能存在多个连通分量！
```
class Solution {
    vector<vector<int>> link;
    int* ptr;
public:
    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {
       // vector<vector<int>> link;
        ptr = new int[N];
        memset(ptr,-1,sizeof(int)*N);
        link.resize(N);
        for(int i=0;i<N;i++)
        {
            vector<int> temp;
            for(int j=0;j<N;j++)
                temp.push_back(0);
            //link.push_back(temp);
        }
        for(int i=0;i<dislikes.size();i++)
        {
            int x = dislikes[i][0];
            int y = dislikes[i][1];
            link[x-1].push_back(y-1);
            link[y-1].push_back(x-1);
        }
        for(int i=0;i<N;i++)
        {
            if(ptr[i]==-1)
            {
                bool r = dfs(i,0);
                if(r==false)
                    return false;
            }
            else
                continue;
        }
    }
    bool dfs(int id,int color)
    {
        if(ptr[id]!=-1)
        {
            if(ptr[id]==color) 
                return true;
            else
                return false;
        }
        else
        {
            ptr[id] = color;
            int x = (color==1?0:1);
            for(int i=0;i<link[id].size();i++)
            {            
                    bool r =dfs(link[id][i],x);
                    if(r==false)
                        return false;                
            }
            return true;
        }      
    }
};
```
