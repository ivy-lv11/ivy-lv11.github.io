---
layout: post
title:  Leetcode-DP
date:   2020-08-24 15:01:35 +0300
image:  07.jpg
tags:   Home
---
## 记录leetcode上面DFS的题目
#### 1. 1519
思路：无向图上的DFS。用link作为邻接矩阵，用count记下子树中每个字母的出现次数
```
class Solution {
    vector<vector<int>> count;
    vector<vector<int>> link;
    int* map;
    string label;
public:
    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        count.resize(n);
        link.resize(n);
        label = labels;
        for(int i=0;i<n;i++)
        {
            count[i].resize(26);
        }
        for(int i=0;i<edges.size();i++)
        {
            link[edges[i][0]].push_back(edges[i][1]);
            link[edges[i][1]].push_back(edges[i][0]);
        }
        
        map = new int[n];
        memset(map,0,n*sizeof(int));
        dfs(0);
        vector<int> re;
        for(int i=0;i<n;i++)
        {
            re.push_back(count[i][label[i]-'a']);
        }
        return re;
    }
    bool dfs(int id)
    {
        if(map[id]==1)
            return false;
        map[id] = 1;
        count[id][label[id]-'a']++;
        if(link[id].empty()==true)
            return false;
        for(int i=0;i<link[id].size();i++)
        {
            bool x = dfs(link[id][i]);
            if(x!=false){
            for(int k=0;k<26;k++)
                count[id][k] += count[link[id][i]][k];
            }
        }
        return true;      
    }
};
```

#### 2. 检查搜索二叉树（面试题04.05）[题目](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)
思路：递归，左右子树都是搜索二叉树，且左子树最大值小于根节点的值，且右子树最小值大于根结点的值，return true; 否则return false
```
struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };

class Solution {
public:
    int get_min(TreeNode* ptr)
    {
        TreeNode* tmp = ptr;
        while(tmp->left!=NULL)
            tmp = tmp->left;
        return tmp->val;
    }
    int get_max(TreeNode* ptr)
    {
          TreeNode* tmp = ptr;
        while(tmp->right!=NULL)
            tmp = tmp->right;
        return tmp->val;  
    }
    bool isValidBST(TreeNode* root) {
        if(root==NULL)
            return true;
        if(root->left==NULL && root->right==NULL)
            return true;
        else if(root->left==NULL && root->right!=NULL)
        {
            bool b1 = isValidBST(root->right);
            if(b1 && get_min(root->right) > root->val)
                return true;
            else
                return false;
        }
        else if(root->left!=NULL && root->right==NULL )
        {
            bool b1 = isValidBST(root->left);
            if(b1 && get_max(root->left) < root->val)
                return true;
            else
                return false;
        }
        else
        {
            bool b1 = isValidBST(root->left);
            bool b2 = isValidBST(root->right);
            if(b1 && b2 && root->val>get_max(root->left) && get_min(root->right) >root->val)
                return true;
            return false;
        }
        return false;
    }
};
```