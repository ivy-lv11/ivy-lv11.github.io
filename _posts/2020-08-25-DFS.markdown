---
layout: post
title:  Leetcode-DP
date:   2020-08-24 15:01:35 +0300
image:  07.jpg
tags:   Home
---
## 记录leetcode上面DFS的题目
#### 1. 1519
思路：无向图上的DFS。用link作为邻接矩阵，用count记下子树中每个字母的出现次数
```
class Solution {
    vector<vector<int>> count;
    vector<vector<int>> link;
    int* map;
    string label;
public:
    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        count.resize(n);
        link.resize(n);
        label = labels;
        for(int i=0;i<n;i++)
        {
            count[i].resize(26);
        }
        for(int i=0;i<edges.size();i++)
        {
            link[edges[i][0]].push_back(edges[i][1]);
            link[edges[i][1]].push_back(edges[i][0]);
        }
        
        map = new int[n];
        memset(map,0,n*sizeof(int));
        dfs(0);
        vector<int> re;
        for(int i=0;i<n;i++)
        {
            re.push_back(count[i][label[i]-'a']);
        }
        return re;
    }
    bool dfs(int id)
    {
        if(map[id]==1)
            return false;
        map[id] = 1;
        count[id][label[id]-'a']++;
        if(link[id].empty()==true)
            return false;
        for(int i=0;i<link[id].size();i++)
        {
            bool x = dfs(link[id][i]);
            if(x!=false){
            for(int k=0;k<26;k++)
                count[id][k] += count[link[id][i]][k];
            }
        }
        return true;      
    }
};
```

#### 2. [检查搜索二叉树](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)
思路：递归，左右子树都是搜索二叉树，且左子树最大值小于根节点的值，且右子树最小值大于根结点的值，return true; 否则return false
```
struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };

class Solution {
public:
    int get_min(TreeNode* ptr)
    {
        TreeNode* tmp = ptr;
        while(tmp->left!=NULL)
            tmp = tmp->left;
        return tmp->val;
    }
    int get_max(TreeNode* ptr)
    {
          TreeNode* tmp = ptr;
        while(tmp->right!=NULL)
            tmp = tmp->right;
        return tmp->val;  
    }
    bool isValidBST(TreeNode* root) {
        if(root==NULL)
            return true;
        if(root->left==NULL && root->right==NULL)
            return true;
        else if(root->left==NULL && root->right!=NULL)
        {
            bool b1 = isValidBST(root->right);
            if(b1 && get_min(root->right) > root->val)
                return true;
            else
                return false;
        }
        else if(root->left!=NULL && root->right==NULL )
        {
            bool b1 = isValidBST(root->left);
            if(b1 && get_max(root->left) < root->val)
                return true;
            else
                return false;
        }
        else
        {
            bool b1 = isValidBST(root->left);
            bool b2 = isValidBST(root->right);
            if(b1 && b2 && root->val>get_max(root->left) && get_min(root->right) >root->val)
                return true;
            return false;
        }
        return false;
    }
};
```
#### 3. [字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)  
思路：回溯算法
```
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        map<char,string> dict;
        dict['2'] = string("abc");
        dict['3'] = string("def");
        dict['4'] = string("ghi");
        dict['5'] = string("jkl");
        dict['6'] = string("mno");
        dict['7'] = string("pqrs");
        dict['8'] = string("tuv");
        dict['9'] = string("wxyz");
        vector<string> re;
        for(int i=0;i<digits.size();i++)
        {
            if(re.empty())
            {
                char ch = digits[i];
                for(int j=0;j<dict[ch].size();j++)
                {
                    char add = dict[ch][j];
                    char t[10];
                    sprintf(t,"%c",add);
                    re.push_back(string(t));
                }
            }
            else
            {
                char ch = digits[i];
                vector<string> pre ;
                for(int j=0;j<dict[ch].size();j++)
                {
                    char add = dict[ch][j];
                    char t[10];
                    sprintf(t,"%c",add);
                    string temp(t);
                    for(int k=0;k<re.size();k++)
                    {
                        pre.push_back( re[k]+temp);
                    }
                }
                re = pre;
            }
        }
        return re;
    }   
};
```
